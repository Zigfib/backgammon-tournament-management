<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backgammon Tournament Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .setup-panel {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }
        
        .setup-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
        }
        
        .input-group label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #2c3e50;
        }
        
        .input-group input, .input-group select {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #27ae60, #229954);
        }
        
        .btn-success:hover {
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.4);
        }
        
        .player-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .player-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 2px solid #dee2e6;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .player-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        
        .player-card h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
            text-align: center;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin: -20px -20px 15px -20px;
        }
        
        .player-card .input-group {
            margin-bottom: 15px;
        }
        
        .player-card .input-group:last-child {
            margin-bottom: 0;
        }
        
        .player-card input {
            background: white;
        }
        
        .elo-input {
            position: relative;
        }
        
        .elo-help {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: #17a2b8;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: help;
            font-weight: bold;
        }
        
        .elo-help:hover {
            background: #138496;
        }
        
        .main-content {
            padding: 20px;
        }
        
        .tabs {
            display: flex;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        
        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            background: #e9ecef;
            border: none;
            font-size: 16px;
            transition: background 0.3s;
        }
        
        .tab.active {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .tournament-table {
            overflow-x: auto;
            margin-bottom: 30px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        th, td {
            padding: 12px;
            text-align: center;
            border: 1px solid #ddd;
        }
        
        th {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            color: white;
            font-weight: bold;
        }
        
        .player-header {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
        }
        
        .stats-row {
            background: #fff3cd;
        }
        
        .diagonal-cell {
            background: #343a40;
            color: white;
        }
        
        .match-input {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .match-input input {
            width: 60px;
            text-align: center;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        
        .vs-text {
            font-weight: bold;
            color: #2c3e50;
        }
        
        .standings-table {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .standings-table th {
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
        }
        
        .position-1 { background: linear-gradient(135deg, #f1c40f, #f39c12); }
        .position-2 { background: linear-gradient(135deg, #95a5a6, #7f8c8d); }
        .position-3 { background: linear-gradient(135deg, #cd7f32, #a0522d); }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .stat-card h3 {
            color: #2c3e50;
            margin-bottom: 15px;
        }
        
        .hidden {
            display: none !important;
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .setup-grid {
                grid-template-columns: 1fr;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            table {
                font-size: 14px;
            }
            
            th, td {
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé≤ Backgammon Tournament Manager</h1>
            <p>Round-robin tournament with ELO ratings</p>
	<div class="save-load-toolbar" style="margin-top:12px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
    		<button class="btn" onclick="saveTournament()">üíæ Save Tournament</button>
    		<button class="btn" onclick="loadTournament()">üìÇ Load Tournament</button>
    		<button class="btn" onclick="exportTournament()">‚¨áÔ∏è Export JSON</button>
    		<label class="btn" style="cursor:pointer; display:inline-flex; align-items:center; gap:8px;">
     		   ‚¨ÜÔ∏è Import JSON
        	<input type="file" id="importFile" accept="application/json" style="display:none" onchange="importTournament(this.files[0])">
    		</label>
	</div>

        </div>
        
        <div class="setup-panel" id="basicSetup">
            <h2>Tournament Setup</h2>
            <div class="setup-grid">
                <div class="input-group">
                    <label for="tournamentName">Tournament Name</label>
                    <input type="text" id="tournamentName" value="Championship 2025">
                </div>
                
                <div class="input-group">
                    <label for="numPlayers">Number of Players (3-32)</label>
                    <input type="number" id="numPlayers" value="6" min="3" max="32">
                </div>
                
                <div class="input-group">
                    <label for="numRounds">Rounds per Matchup</label>
                    <select id="numRounds">
                        <option value="1">1 Round</option>
                        <option value="2" selected>2 Rounds</option>
                        <option value="3">3 Rounds</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label for="maxPoints">Match To</label>
                    <input type="number" id="maxPoints" value="11" min="1" max="25">
                </div>
                
                <div class="input-group">
                    <label for="rankingSystem">Ranking System</label>
                    <select id="rankingSystem">
                        <option value="standard">Standard - All positions by points + tiebreakers</option>
                        <option value="hybrid">Hybrid - Top by points, lower by ELO improvement</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label for="scoreEntryMode">Score Entry Permissions</label>
                    <select id="scoreEntryMode">
                        <option value="admin-only">Admin Only - Tournament director enters all scores</option>
                        <option value="player-entry" selected>Player Entry - Players enter scores, admin can override</option>
                        <option value="dual-confirm">Dual Confirmation - Both players must confirm each result</option>
                        <option value="open-access">Open Access - Anyone can enter/edit any score</option>
                    </select>
                </div>
            </div>
            
            <button class="btn" onclick="goToPlayerSetup()">Setup Players ‚Üí</button>
        </div>

        <div class="setup-panel hidden" id="playerSetup">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2>Player Information</h2>
                <button class="btn" style="background: #6c757d;" onclick="backToBasicSetup()">‚Üê Back to Tournament Setup</button>
            </div>
            
            <div class="player-cards" id="playerCards">
                <!-- Player cards will be generated here -->
            </div>
            
            <div style="margin-top: 20px; text-align: center;">
                <button class="btn btn-success" onclick="startTournament()">Start Tournament</button>
            </div>
        </div>
        
        <div class="main-content hidden" id="mainContent">
            <div class="tabs">
                <button class="tab active" onclick="switchTab('matches')">Match Entry</button>
                <button class="tab" onclick="switchTab('table')">Tournament Table</button>
                <button class="tab" onclick="switchTab('standings')">Standings</button>
                <button class="tab" onclick="switchTab('stats')">Statistics</button>
            </div>
            
            <div id="matchesTab" class="tab-content active">
                <h2>Enter Match Results</h2>
                <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0; color: #1976d2;">üìä ELO Rating System Active</h4>
                    <p style="margin: 0; font-size: 14px; color: #424242;">
                        ELO ratings will update automatically after each match. Larger victories have slightly more impact on rating changes.
                        <strong>K-Factor: 32</strong> | <strong>Margin Bonus: Up to 2x</strong>
                    </p>
                </div>
                <div id="matchInputs">
                    <!-- Match input forms will be generated here -->
                </div>
            </div>
            
            <div id="tableTab" class="tab-content">
                <h2>Tournament Table</h2>
                <div class="tournament-table">
                    <table id="tournamentTable">
                        <!-- Tournament table will be generated here -->
                    </table>
                </div>
            </div>
            
            <div id="standingsTab" class="tab-content">
                <h2>Current Standings</h2>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #28a745;" id="rankingExplanation">
                    <!-- Dynamic ranking explanation will be inserted here -->
                </div>
                <div class="tournament-table">
                    <table id="standingsTable" class="standings-table">
                        <!-- Standings will be generated here -->
                    </table>
                </div>
            </div>
            
            <div id="statsTab" class="tab-content">
                <h2>Player Statistics</h2>
                <div class="stats-grid" id="statsGrid">
                    <!-- Player stats will be generated here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        let tournament = {
            name: '',
            players: [],
            numRounds: 2,
            maxPoints: 11,
            matches: [],
            results: {},
            rankingSystem: 'standard',
            scoreEntryMode: 'player-entry',
            isAdmin: false // Will be set based on access method
        };

        function goToPlayerSetup() {
            const numPlayers = parseInt(document.getElementById('numPlayers').value);
            
            if (numPlayers < 3 || numPlayers > 32) {
                alert('Please enter a valid number of players (3-32)');
                return;
            }
            
            generatePlayerCards(numPlayers);
            
            document.getElementById('basicSetup').classList.add('hidden');
            document.getElementById('playerSetup').classList.remove('hidden');
        }

        function backToBasicSetup() {
            document.getElementById('playerSetup').classList.add('hidden');
            document.getElementById('basicSetup').classList.remove('hidden');
        }

        function generatePlayerCards(numPlayers) {
            const container = document.getElementById('playerCards');
            if (!container) {
                console.error('Player cards container not found');
                return;
            }
            
            container.innerHTML = '';
            
            for (let i = 1; i <= numPlayers; i++) {
                const card = document.createElement('div');
                card.className = 'player-card';
                card.innerHTML = `
                    <h3>Player ${i}</h3>
                    
                    <div class="input-group">
                        <label for="playerName${i}">Full Name *</label>
                        <input type="text" id="playerName${i}" value="Player ${i}" required>
                    </div>
                    
                    <div class="input-group">
                        <label for="playerElo${i}">Starting ELO Rating *</label>
                        <div class="elo-input">
                            <input type="number" id="playerElo${i}" value="1500" min="100" max="3000" required>
                            <div class="elo-help" title="Typical range: 1000-2500. New players: ~1200-1500">?</div>
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label for="playerEmail${i}">Email Address</label>
                        <input type="email" id="playerEmail${i}" placeholder="player${i}@email.com">
                    </div>
                    
                    <div class="input-group">
                        <label for="playerPhone${i}">Phone Number</label>
                        <input type="tel" id="playerPhone${i}" placeholder="+1 (555) 123-4567">
                    </div>
                `;
                container.appendChild(card);
            }
        }

        function setupTournament() {
            const numPlayers = parseInt(document.getElementById('numPlayers').value);
            const playersSetup = document.getElementById('playersSetup');
            
            playersSetup.innerHTML = '';
            playersSetup.classList.remove('hidden');
            
            for (let i = 1; i <= numPlayers; i++) {
                const div = document.createElement('div');
                div.className = 'player-input';
                div.innerHTML = `
                    <label for="player${i}">Player ${i} Name</label>
                    <input type="text" id="player${i}" value="Player ${i}" placeholder="Enter player name">
                `;
                playersSetup.appendChild(div);
            }
            
            document.getElementById('startBtn').classList.remove('hidden');
        }

        function startTournament() {
            // Validate required fields
            const numPlayers = parseInt(document.getElementById('numPlayers').value);
            let hasErrors = false;
            
            for (let i = 1; i <= numPlayers; i++) {
                const name = document.getElementById(`playerName${i}`).value.trim();
                const elo = document.getElementById(`playerElo${i}`).value;
                
                if (!name) {
                    alert(`Please enter a name for Player ${i}`);
                    return;
                }
                
                if (!elo || elo < 100 || elo > 3000) {
                    alert(`Please enter a valid ELO rating for ${name} (100-3000)`);
                    return;
                }
            }
            
            // Collect tournament settings
            tournament.name = document.getElementById('tournamentName').value;
            tournament.numRounds = parseInt(document.getElementById('numRounds').value);
            tournament.maxPoints = parseInt(document.getElementById('maxPoints').value);
            tournament.rankingSystem = document.getElementById('rankingSystem').value;
            tournament.scoreEntryMode = document.getElementById('scoreEntryMode').value;
            
            // Collect player information
            tournament.players = [];
            
            for (let i = 1; i <= numPlayers; i++) {
                const name = document.getElementById(`playerName${i}`).value.trim();
                const startingElo = parseInt(document.getElementById(`playerElo${i}`).value);
                const email = document.getElementById(`playerEmail${i}`).value.trim();
                const phone = document.getElementById(`playerPhone${i}`).value.trim();
                
                tournament.players.push({
                    id: i - 1,
                    name: name,
                    startingElo: startingElo,
                    currentElo: startingElo, // Will change during tournament
                    email: email,
                    phone: phone,
                    matches: 0,
                    points: 0,
                    goalDiff: 0
                });
            }
            
            generateMatches();
            document.getElementById('playerSetup').classList.add('hidden');
            document.getElementById('mainContent').classList.remove('hidden');
            updateAll();
        }

        function generateMatches() {
            tournament.matches = [];
            let matchId = 0;
            
            // Generate all player vs player combinations
            for (let i = 0; i < tournament.players.length; i++) {
                for (let j = i + 1; j < tournament.players.length; j++) {
                    for (let round = 1; round <= tournament.numRounds; round++) {
                        tournament.matches.push({
                            id: matchId++,
                            player1: i,
                            player2: j,
                            round: round,
                            player1Score: null,
                            player2Score: null,
                            completed: false
                        });
                    }
                }
            }
            
            // Initialize results tracking
            tournament.results = {};
            tournament.players.forEach(p1 => {
                tournament.results[p1.id] = {};
                tournament.players.forEach(p2 => {
                    if (p1.id !== p2.id) {
                        tournament.results[p1.id][p2.id] = [];
                    }
                });
            });
        }

        function calculateELO(winnerELO, loserELO, winnerScore, loserScore) {
            // ELO calculation parameters
            const K_FACTOR = 32; // Standard K-factor for chess/backgammon
            
            // Calculate expected scores
            const expectedWinner = 1 / (1 + Math.pow(10, (loserELO - winnerELO) / 400));
            const expectedLoser = 1 / (1 + Math.pow(10, (winnerELO - loserELO) / 400));
            
            // Score multiplier based on margin of victory
            // Larger victories have slightly more impact
            const marginMultiplier = Math.min(1 + (winnerScore - loserScore) / 20, 2.0);
            
            // Calculate new ELO ratings
            const newWinnerELO = Math.round(winnerELO + K_FACTOR * marginMultiplier * (1 - expectedWinner));
            const newLoserELO = Math.round(loserELO + K_FACTOR * marginMultiplier * (0 - expectedLoser));
            
            return {
                newWinnerELO: newWinnerELO,
                newLoserELO: newLoserELO,
                winnerChange: newWinnerELO - winnerELO,
                loserChange: newLoserELO - loserELO
            };
        }

        function updateMatchResult(matchId, player1Score, player2Score) {
            const match = tournament.matches.find(m => m.id === matchId);
            if (!match) return;
            
            // Store previous ELO values for potential rollback
            const prevPlayer1ELO = tournament.players[match.player1].currentElo;
            const prevPlayer2ELO = tournament.players[match.player2].currentElo;
            
            match.player1Score = player1Score !== '' ? parseInt(player1Score) : null;
            match.player2Score = player2Score !== '' ? parseInt(player2Score) : null;
            match.completed = match.player1Score !== null && match.player2Score !== null;
            
            if (match.completed) {
                // Determine winner and assign points
                let p1Points, p2Points;
                let winnerELO, loserELO, winnerScore, loserScore;
                let isPlayer1Winner = match.player1Score > match.player2Score;
                
                if (isPlayer1Winner) {
                    p1Points = 3; // Winner gets 3 points
                    p2Points = 1; // Loser gets 1 point
                    winnerELO = prevPlayer1ELO;
                    loserELO = prevPlayer2ELO;
                    winnerScore = match.player1Score;
                    loserScore = match.player2Score;
                } else {
                    p1Points = 1;
                    p2Points = 3;
                    winnerELO = prevPlayer2ELO;
                    loserELO = prevPlayer1ELO;
                    winnerScore = match.player2Score;
                    loserScore = match.player1Score;
                }
                
                // Calculate new ELO ratings
                const eloResult = calculateELO(winnerELO, loserELO, winnerScore, loserScore);
                
                // Update player ELO ratings
                if (isPlayer1Winner) {
                    tournament.players[match.player1].currentElo = eloResult.newWinnerELO;
                    tournament.players[match.player2].currentElo = eloResult.newLoserELO;
                } else {
                    tournament.players[match.player1].currentElo = eloResult.newLoserELO;
                    tournament.players[match.player2].currentElo = eloResult.newWinnerELO;
                }
                
                // Store result with ELO changes
                const resultData = {
                    round: match.round,
                    score1: match.player1Score,
                    score2: match.player2Score,
                    points1: p1Points,
                    points2: p2Points,
                    elo1Before: prevPlayer1ELO,
                    elo2Before: prevPlayer2ELO,
                    elo1After: tournament.players[match.player1].currentElo,
                    elo2After: tournament.players[match.player2].currentElo,
                    elo1Change: tournament.players[match.player1].currentElo - prevPlayer1ELO,
                    elo2Change: tournament.players[match.player2].currentElo - prevPlayer2ELO
                };
                
                // Remove any existing result for this round first
                tournament.results[match.player1][match.player2] = 
                    tournament.results[match.player1][match.player2].filter(r => r.round !== match.round);
                
                // Add the new result
                tournament.results[match.player1][match.player2].push(resultData);
                
            } else {
                // Match is incomplete - remove result and restore ELO
                tournament.results[match.player1][match.player2] = 
                    tournament.results[match.player1][match.player2].filter(r => r.round !== match.round);
                
                // Restore previous ELO ratings
                tournament.players[match.player1].currentElo = prevPlayer1ELO;
                tournament.players[match.player2].currentElo = prevPlayer2ELO;
            }
            
            updateAll();
        }

        function calculateStats() {
            // Reset player stats
            tournament.players.forEach(player => {
                player.matches = 0;
                player.points = 0;
                player.goalDiff = 0;
            });
            
            // Calculate stats from completed matches
            tournament.matches.forEach(match => {
                if (match.completed) {
                    const p1 = tournament.players[match.player1];
                    const p2 = tournament.players[match.player2];
                    
                    p1.matches++;
                    p2.matches++;
                    
                    const goalDiff = match.player1Score - match.player2Score;
                    p1.goalDiff += goalDiff;
                    p2.goalDiff -= goalDiff;
                    
                    if (match.player1Score > match.player2Score) {
                        p1.points += 3;
                        p2.points += 1;
                    } else {
                        p1.points += 1;
                        p2.points += 3;
                    }
                }
            });
        }

        function updateMatchInputs() {
            const container = document.getElementById('matchInputs');
            if (!container || !tournament.players || tournament.players.length === 0) {
                return; // Exit if container doesn't exist or no players
            }
            
            container.innerHTML = '';
            
            tournament.matches.forEach(match => {
                const div = document.createElement('div');
                div.className = 'match-input';
                
                const p1Name = tournament.players[match.player1].name;
                const p2Name = tournament.players[match.player2].name;
                const p1ELO = tournament.players[match.player1].currentElo;
                const p2ELO = tournament.players[match.player2].currentElo;
                
                // Calculate expected outcome for display
                const expectedP1 = (1 / (1 + Math.pow(10, (p2ELO - p1ELO) / 400)) * 100).toFixed(0);
                const expectedP2 = (100 - expectedP1);
                
                div.innerHTML = `
                    <div>
                        <label>${p1Name} (${p1ELO})</label>
                        <small style="color: #666; font-size: 12px;">Expected: ${expectedP1}%</small>
                        <input type="number" 
                               id="match${match.id}p1"
                               value="${match.player1Score || ''}" 
                               min="0" 
                               max="${tournament.maxPoints}"
                               onchange="updateMatchResult(${match.id}, this.value, document.getElementById('match${match.id}p2').value)">
                    </div>
                    <div class="vs-text">vs<br>Round ${match.round}</div>
                    <div>
                        <label>${p2Name} (${p2ELO})</label>
                        <small style="color: #666; font-size: 12px;">Expected: ${expectedP2}%</small>
                        <input type="number" 
                               id="match${match.id}p2"
                               value="${match.player2Score || ''}" 
                               min="0" 
                               max="${tournament.maxPoints}"
                               onchange="updateMatchResult(${match.id}, document.getElementById('match${match.id}p1').value, this.value)">
                    </div>
                `;
                
                container.appendChild(div);
            });
        }

        function updateTournamentTable() {
            const table = document.getElementById('tournamentTable');
            if (!table || !tournament.players || tournament.players.length === 0) {
                return; // Exit if table doesn't exist or no players
            }
            
            const players = tournament.players;
            
            let html = '<thead><tr><th>Stats / Player</th>';
            players.forEach(player => {
                html += `<th class="player-header">${player.name}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            // Stats rows
            const statRows = [
                { label: 'Current ELO', key: 'currentElo' },
                { label: 'ELO Improvement', key: 'eloImprovement' },
                { label: 'Goal Difference', key: 'goalDiff' },
                { label: 'Total Points', key: 'points' },
                { label: '% of Possible Points', key: 'pointsPercent' },
                { label: 'Total Matches', key: 'matches' },
                { label: 'Remaining Matches', key: 'remainingMatches' }
            ];
            
            statRows.forEach(stat => {
                html += `<tr class="stats-row"><td><strong>${stat.label}</strong></td>`;
                players.forEach(player => {
                    let value;
                    switch(stat.key) {
                        case 'currentElo':
                            value = player.currentElo || player.startingElo;
                            break;
                        case 'eloImprovement':
                            const improvement = (player.currentElo || player.startingElo) - player.startingElo;
                            value = (improvement > 0 ? '+' : '') + improvement;
                            break;
                        case 'pointsPercent':
                            value = player.matches > 0 ? Math.round((player.points / (player.matches * 3)) * 100) + '%' : '0%';
                            break;
                        case 'remainingMatches':
                            const totalMatches = (tournament.players.length - 1) * tournament.numRounds;
                            value = totalMatches - player.matches;
                            break;
                        default:
                            value = player[stat.key] || 0;
                    }
                    html += `<td>${value}</td>`;
                });
                html += '</tr>';
            });
            
            // Player vs player results
            players.forEach((player, i) => {
                html += `<tr><td class="player-header">${player.name}</td>`;
                players.forEach((opponent, j) => {
                    if (i === j) {
                        html += '<td class="diagonal-cell">‚Äî</td>';
                    } else {
                        const results = tournament.results && tournament.results[i] && tournament.results[i][j] ? tournament.results[i][j] : [];
                        let cellContent = '';
                        results.forEach(result => {
                            cellContent += `${result.points1}<br>`;
                        });
                        html += `<td>${cellContent || '‚Äî'}</td>`;
                    }
                });
                html += '</tr>';
            });
            
            html += '</tbody>';
            table.innerHTML = html;
        }

        function calculateTiebreakers(player, allPlayers) {
            const playerResults = tournament.results[player.id] || {};
            
            // 1. Number of wins against players with the same number of points
            const playersWithSamePoints = allPlayers.filter(p => p.points === player.points && p.id !== player.id);
            let winsAgainstSamePoints = 0;
            
            playersWithSamePoints.forEach(opponent => {
                const resultsVsOpponent = playerResults[opponent.id] || [];
                resultsVsOpponent.forEach(result => {
                    if (result.points1 === 3) { // Player won this match
                        winsAgainstSamePoints++;
                    }
                });
            });
            
            // 2. Modified Buchholz - sum of points of all opponents played
            let buchholzScore = 0;
            const opponentsPlayed = new Set();
            
            // Check all results where this player participated
            Object.keys(playerResults).forEach(opponentId => {
                const results = playerResults[opponentId];
                if (results.length > 0) {
                    opponentsPlayed.add(parseInt(opponentId));
                }
            });
            
            // Also check results where this player was the opponent
            allPlayers.forEach(otherPlayer => {
                if (otherPlayer.id !== player.id) {
                    const otherResults = tournament.results[otherPlayer.id] || {};
                    const resultsVsThisPlayer = otherResults[player.id] || [];
                    if (resultsVsThisPlayer.length > 0) {
                        opponentsPlayed.add(otherPlayer.id);
                    }
                }
            });
            
            // Sum up the points of all opponents played
            opponentsPlayed.forEach(opponentId => {
                const opponent = allPlayers.find(p => p.id === opponentId);
                if (opponent) {
                    buchholzScore += opponent.points;
                }
            });
            
            // 3. Goal Difference (already calculated)
            const goalDifference = player.goalDiff;
            
            return {
                winsAgainstSamePoints,
                buchholzScore,
                goalDifference
            };
        }

        function updateStandings() {
            const table = document.getElementById('standingsTable');
            if (!table || !tournament.players || tournament.players.length === 0) {
                return; // Exit if table doesn't exist or no players
            }
            
            let sortedPlayers;
            
            if (tournament.rankingSystem === 'hybrid') {
                sortedPlayers = calculateHybridRanking();
            } else {
                sortedPlayers = calculateStandardRanking();
            }
            
            // Generate table HTML
            let html = `<thead><tr>`;
            
            if (tournament.rankingSystem === 'hybrid') {
                html += `
                    <th>Position</th>
                    <th>Player</th>
                    <th>Rank Method</th>
                    <th>Points</th>
                    <th>ELO Change</th>
                    <th>TB1: Same</th>
                    <th>TB2: Buchholz</th>
                    <th>TB3: Goal Diff</th>
                    <th>Current ELO</th>
                `;
            } else {
                html += `
                    <th>Position</th>
                    <th>Player</th>
                    <th>Points</th>
                    <th>Matches</th>
                    <th>TB1: Same Points</th>
                    <th>TB2: Buchholz</th>
                    <th>TB3: Goal Diff</th>
                    <th>ELO</th>
                `;
            }
            
            html += `</tr></thead><tbody>`;
            
            sortedPlayers.forEach((player, index) => {
                const positionClass = index < 3 ? `position-${index + 1}` : '';
                html += `<tr class="${positionClass}">`;
                
                if (tournament.rankingSystem === 'hybrid') {
                    const eloChange = (player.currentElo || player.startingElo) - player.startingElo;
                    html += `
                        <td><strong>${index + 1}</strong></td>
                        <td>${player.name}</td>
                        <td><span style="font-size: 12px; padding: 2px 6px; border-radius: 3px; background: ${player.rankMethod === 'points' ? '#e3f2fd' : '#fff3e0'}; color: ${player.rankMethod === 'points' ? '#1976d2' : '#f57c00'};">${player.rankMethod === 'points' ? 'Points' : 'ELO'}</span></td>
                        <td>${player.points}</td>
                        <td>${eloChange > 0 ? '+' : ''}${eloChange}</td>
                        <td>${player.tiebreakers.winsAgainstSamePoints}</td>
                        <td>${player.tiebreakers.buchholzScore}</td>
                        <td>${player.goalDiff > 0 ? '+' : ''}${player.goalDiff}</td>
                        <td>${player.currentElo || player.startingElo}</td>
                    `;
                } else {
                    html += `
                        <td><strong>${index + 1}</strong></td>
                        <td>${player.name}</td>
                        <td>${player.points}</td>
                        <td>${player.matches}</td>
                        <td>${player.tiebreakers.winsAgainstSamePoints}</td>
                        <td>${player.tiebreakers.buchholzScore}</td>
                        <td>${player.goalDiff > 0 ? '+' : ''}${player.goalDiff}</td>
                        <td>${player.currentElo || player.startingElo}</td>
                    `;
                }
                
                html += `</tr>`;
            });
            
            html += '</tbody>';
            table.innerHTML = html;
        }

        function calculateStandardRanking() {
            // Calculate tiebreakers for all players
            const playersWithTiebreakers = tournament.players.map(player => ({
                ...player,
                tiebreakers: calculateTiebreakers(player, tournament.players)
            }));
            
            // Sort by: 1) Points, 2) Wins against same points, 3) Buchholz, 4) Goal Diff
            return playersWithTiebreakers.sort((a, b) => {
                // Primary: Total points (descending)
                if (b.points !== a.points) return b.points - a.points;
                
                // Tiebreaker 1: Wins against players with same points (descending)
                if (b.tiebreakers.winsAgainstSamePoints !== a.tiebreakers.winsAgainstSamePoints) {
                    return b.tiebreakers.winsAgainstSamePoints - a.tiebreakers.winsAgainstSamePoints;
                }
                
                // Tiebreaker 2: Modified Buchholz (descending)
                if (b.tiebreakers.buchholzScore !== a.tiebreakers.buchholzScore) {
                    return b.tiebreakers.buchholzScore - a.tiebreakers.buchholzScore;
                }
                
                // Tiebreaker 3: Goal Difference (descending)
                return b.tiebreakers.goalDifference - a.tiebreakers.goalDifference;
            });
        }

        function calculateHybridRanking() {
            // Calculate tiebreakers for all players
            const playersWithTiebreakers = tournament.players.map(player => ({
                ...player,
                tiebreakers: calculateTiebreakers(player, tournament.players),
                eloChange: (player.currentElo || player.startingElo) - player.startingElo
            }));
            
            // First, sort everyone by points to determine groups
            const sortedByPoints = [...playersWithTiebreakers].sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                
                // Use tiebreakers for points-based sorting
                if (b.tiebreakers.winsAgainstSamePoints !== a.tiebreakers.winsAgainstSamePoints) {
                    return b.tiebreakers.winsAgainstSamePoints - a.tiebreakers.winsAgainstSamePoints;
                }
                if (b.tiebreakers.buchholzScore !== a.tiebreakers.buchholzScore) {
                    return b.tiebreakers.buchholzScore - a.tiebreakers.buchholzScore;
                }
                return b.tiebreakers.goalDifference - a.tiebreakers.goalDifference;
            });
            
            // Assign ranking method: first 2 by points, next 2 by ELO, etc.
            const finalRanking = [];
            let position = 0;
            
            while (position < sortedByPoints.length) {
                if (position < 2) {
                    // First 2 positions: rank by points
                    const player = { ...sortedByPoints[position], rankMethod: 'points' };
                    finalRanking.push(player);
                } else if (position < 4) {
                    // Next 2 positions: rank by ELO improvement
                    const remainingPlayers = sortedByPoints.slice(2);
                    const sortedByELO = remainingPlayers.sort((a, b) => {
                        if (b.eloChange !== a.eloChange) return b.eloChange - a.eloChange;
                        
                        // Use same tiebreakers for ELO-based sorting
                        if (b.tiebreakers.winsAgainstSamePoints !== a.tiebreakers.winsAgainstSamePoints) {
                            return b.tiebreakers.winsAgainstSamePoints - a.tiebreakers.winsAgainstSamePoints;
                        }
                        if (b.tiebreakers.buchholzScore !== a.tiebreakers.buchholzScore) {
                            return b.tiebreakers.buchholzScore - a.tiebreakers.buchholzScore;
                        }
                        return b.tiebreakers.goalDifference - a.tiebreakers.goalDifference;
                    });
                    
                    if (position - 2 < sortedByELO.length) {
                        const player = { ...sortedByELO[position - 2], rankMethod: 'elo' };
                        finalRanking.push(player);
                    }
                } else {
                    // Continue alternating pattern: positions 5-6 by points, 7-8 by ELO, etc.
                    const cyclePosition = (position - 4) % 4;
                    const usePoints = cyclePosition < 2;
                    
                    const remainingPlayers = sortedByPoints.slice(4);
                    
                    if (usePoints) {
                        // Rank by points
                        const pointsRanked = remainingPlayers.sort((a, b) => {
                            if (b.points !== a.points) return b.points - a.points;
                            if (b.tiebreakers.winsAgainstSamePoints !== a.tiebreakers.winsAgainstSamePoints) {
                                return b.tiebreakers.winsAgainstSamePoints - a.tiebreakers.winsAgainstSamePoints;
                            }
                            if (b.tiebreakers.buchholzScore !== a.tiebreakers.buchholzScore) {
                                return b.tiebreakers.buchholzScore - a.tiebreakers.buchholzScore;
                            }
                            return b.tiebreakers.goalDifference - a.tiebreakers.goalDifference;
                        });
                        
                        const pointsIndex = Math.floor((position - 4) / 2);
                        if (pointsIndex < pointsRanked.length) {
                            const player = { ...pointsRanked[pointsIndex], rankMethod: 'points' };
                            finalRanking.push(player);
                        }
                    } else {
                        // Rank by ELO
                        const eloRanked = remainingPlayers.sort((a, b) => {
                            if (b.eloChange !== a.eloChange) return b.eloChange - a.eloChange;
                            if (b.tiebreakers.winsAgainstSamePoints !== a.tiebreakers.winsAgainstSamePoints) {
                                return b.tiebreakers.winsAgainstSamePoints - a.tiebreakers.winsAgainstSamePoints;
                            }
                            if (b.tiebreakers.buchholzScore !== a.tiebreakers.buchholzScore) {
                                return b.tiebreakers.buchholzScore - a.tiebreakers.buchholzScore;
                            }
                            return b.tiebreakers.goalDifference - a.tiebreakers.goalDifference;
                        });
                        
                        const eloIndex = Math.floor((position - 4) / 2);
                        if (eloIndex < eloRanked.length) {
                            const player = { ...eloRanked[eloIndex], rankMethod: 'elo' };
                            finalRanking.push(player);
                        }
                    }
                }
                position++;
            }
            
            return finalRanking;
        }

        function updateStats() {
            const container = document.getElementById('statsGrid');
            if (!container || !tournament.players || tournament.players.length === 0) {
                return; // Exit if container doesn't exist or no players
            }
            
            container.innerHTML = '';
            
            tournament.players.forEach(player => {
                const totalPossible = (tournament.players.length - 1) * tournament.numRounds * 3;
                const completionPercent = player.matches > 0 ? Math.round((player.matches / ((tournament.players.length - 1) * tournament.numRounds)) * 100) : 0;
                const eloChange = (player.currentElo || player.startingElo) - player.startingElo;
                
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <h3>${player.name}</h3>
                    <p><strong>Current Points:</strong> ${player.points}</p>
                    <p><strong>Matches Played:</strong> ${player.matches}</p>
                    <p><strong>Completion:</strong> ${completionPercent}%</p>
                    <p><strong>Goal Difference:</strong> ${player.goalDiff > 0 ? '+' : ''}${player.goalDiff}</p>
                    <p><strong>Starting ELO:</strong> ${player.startingElo}</p>
                    <p><strong>Current ELO:</strong> ${player.currentElo || player.startingElo}</p>
                    <p><strong>ELO Change:</strong> ${eloChange > 0 ? '+' : ''}${eloChange}</p>
                    <p><strong>Email:</strong> ${player.email || 'Not provided'}</p>
                    <p><strong>Phone:</strong> ${player.phone || 'Not provided'}</p>
                    <p><strong>Points Per Match:</strong> ${player.matches > 0 ? (player.points / player.matches).toFixed(1) : '0'}</p>
                `;
                container.appendChild(card);
            });
        }

        function updateAll() {
            if (!tournament.players || tournament.players.length === 0) {
                return; // Don't update if no tournament data
            }
            
            calculateStats();
            updateMatchInputs();
            updateTournamentTable();
            updateRankingExplanation();
            updateStandings();
            updateStats();
        }

        function updateRankingExplanation() {
            const explanationDiv = document.getElementById('rankingExplanation');
            if (!explanationDiv) return;
            
            if (tournament.rankingSystem === 'hybrid') {
                explanationDiv.innerHTML = `
                    <h4 style="margin: 0 0 10px 0; color: #155724;">üèÜ Hybrid Ranking System</h4>
                    <p style="margin: 0 0 8px 0; font-size: 14px; color: #495057;">
                        <strong>Positions 1-2:</strong> Ranked by Points + Tiebreakers ‚Üí 
                        <strong>Positions 3-4:</strong> Ranked by ELO Improvement + Tiebreakers ‚Üí 
                        <strong>Continues alternating...</strong>
                    </p>
                    <small style="color: #6c757d; font-size: 12px;">
                        Tiebreakers (same for both methods): 1) Wins vs same criteria players | 2) Buchholz score | 3) Goal difference
                    </small>
                `;
            } else {
                explanationDiv.innerHTML = `
                    <h4 style="margin: 0 0 10px 0; color: #155724;">üèÜ Standard Ranking System</h4>
                    <p style="margin: 0; font-size: 14px; color: #495057;">
                        <strong>1.</strong> Total Points ‚Üí 
                        <strong>2.</strong> Wins vs Same Points ‚Üí 
                        <strong>3.</strong> Buchholz Score ‚Üí 
                        <strong>4.</strong> Goal Difference
                    </p>
                    <small style="color: #6c757d; font-size: 12px;">
                        TB1: Head-to-head wins against players with equal points | 
                        TB2: Sum of all opponents' points | 
                        TB3: Point differential
                    </small>
                `;
            }
        }

        function switchTab(tabName) {
            // Remove active class from all tabs and content
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to clicked tab and corresponding content
            event.target.classList.add('active');
            document.getElementById(tabName + 'Tab').classList.add('active');
        }

        // Initialize with default setup - removed to prevent early execution
        // setupTournament();

// === SAVE & LOAD FUNCTIONS ===
function saveTournament() {
    if (!tournament.players || tournament.players.length === 0) {
        alert("No tournament to save yet!");
        return;
    }
    localStorage.setItem("backgammonTournament", JSON.stringify(tournament));
    alert("‚úÖ Tournament saved successfully!");
}

function loadTournament() {
    const data = localStorage.getItem("backgammonTournament");
    if (!data) {
        alert("‚ö†Ô∏è No saved tournament found.");
        return;
    }
    tournament = JSON.parse(data);

    // Restore UI
    document.getElementById("basicSetup").classList.add("hidden");
    document.getElementById("playerSetup").classList.add("hidden");
    document.getElementById("mainContent").classList.remove("hidden");

    updateAll();
    alert("üìÇ Tournament loaded!");
}

    </script>
</body>
</html>